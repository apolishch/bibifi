#!/usr/bin/env ruby
require 'optparse'
require 'socket'
require 'timeout'
require 'json'
require 'openssl'

Signal.trap('INT')  { exit 0 } # Trap ^C      == "INT"
Signal.trap('TERM') { exit 0 } # Trap `Kill ` == "TERM"

SECRET_KEY = 'HUDFaSDh9130fsaklrm1d>>>Dsax__+d1'
EXIT_CODE  = 255

def generate_hash(value)
    OpenSSL::HMAC.hexdigest(
        OpenSSL::Digest.new('sha256'),
        SECRET_KEY,
        value
    ).strip()
end

def debug(msg)
  # Comment below to disable all debug messages
  #puts msg
end

# All other errors, specified throughout this document or
# unrecoverable errors not explicitly discussed, should prompt the
# program to exit with return code 255
# >>>> it's from RAILS 
# >>>> http://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html
#rescue_from 'SystemCallError' do |e|
    #debug e.class.name.to_s
    #exit(EXIT_CODE)
#end

# Numeric inputs are positive and provided in decimal without any
# leading 0's (should match /(0|[1-9][0-9]*)/). Thus "42" is a valid
# input number but the octal "052" or hexadecimal "0x2a" are not.
# Any reference to "number" below refers to this input specification.

def is_valid_balance?(balance, silent=0)
    # Balances and currency amounts are specified as a number
    # indicating a whole amount and a fractional input separated
    # by a period. The fractional input is in decimal and is always
    # two digits and thus can include a leading 0 (should match /[0-9]{2}/).
    # The interpretation of the fractional amount v is that of having
    # value equal to v/100 of a whole amount (akin to cents and dollars in
    # US currency). Balances are bounded from 0.00 to 4294967295.99.
    if balance[0] != "0" && balance =~ /^(\d{1,10}).(\d{2})$/
        balance = balance.to_f
        if balance >= 0.0 && balance <= 4294967295.99
            return true
        end
    end

    debug "Invalid balance: #{balance}" unless silent
    false
end

def is_valid_amount?(amount)
    # Uses the same validation as is_valid_balance?
    result = is_valid_balance?(amount, 1)
    debug "Invalid amount: #{amount}" unless result 

    return result
end

def is_valid_account?(account)
  if account.length >= 1 \
    && account.length <= 250 \
    && account =~ /[_\-\.0-9a-z]/
      return true
  end

  debug "Invalid account: #{account}"
  false
end

def is_valid_ip?(ip)
  if ip =~ /^(\d{1,3}).(\d{1,3}).(\d{1,3}).(\d{1,3})$/
    return true
  end

  debug "Invalid ip #{ip}"
  false
end

def is_valid_port?(port)
  # Length check
  if port.length > 4096
    debug "Invalid length for port (>4096)"
    return false
  end

  # p==0 means invalid integer
  # p<1024 and p>65535 are invalid
  p = port.to_i
  if p!=0 && p >= 1024 && p <= 65535
    return true
  end
  
  debug "Invalid port: #{p}"
  false
end

def is_valid_auth_file?(auth_file, silent=0)
  if ![".",".."].include?(auth_file) \
    && auth_file.length >= 1 \
    && auth_file.length <= 255 \
    && auth_file =~ /[_\-\.0-9a-z]/
      return true
  end

  debug "Invalid auth file: #{auth_file}" unless silent
  false
end

def is_valid_card_file?(card_file)
  result = is_valid_auth_file?(card_file, 1)

  debug "Invalid card_file: #{card_file}" unless result 
  return result
end

def are_valid_args?(args)
  # Account Name
  if !args[:account] || !is_valid_account?(args[:account])
    debug "are_valid_args? invalid account"
    return false
  end

  # Card File
  if !args[:card_file] || !is_valid_card_file?(args[:card_file])
    debug "are_valid_args? invalid card file"
    return false
  end

  # Card File
  if !args[:auth_file] || !is_valid_card_file?(args[:auth_file])
    debug "are_valid_args? invalid auth file"
    return false
  end

  # Operations
  if !args[:operation] || !["-n","-d","-w","-g"].include?(args[:operation])
    debug "are_valid_args? invalid operation"
    return false
  end

  # -n
  if args[:operation] == "-n" && !is_valid_balance?(args[:operation_value])
    debug "are_valid_args? invalid balance for -n operation"
    return false
  end

  # -d, -w
  if ["-d","-w"].include?(args[:operation]) && !is_valid_amount?(args[:operation_value])
    debug "are_valid_args? invalid amount for operations -d or -w"
    return false
  end

  return true
end

def operation_n(args)
    all = File.open(args[:auth_file], "r").read
    found_account = false
    all.split("\n").each do |entry|
        values = entry.split(";")
        if values[0] == args[:account]
            found_account = true
        end
    end

    if found_account
        return { :error => "Account already exists"}
    end

    File.open(args[:auth_file], "a") do |f|
        f << "#{args[:account]};n;;#{Time.now}\n"
        f << "#{args[:account]};d;#{args[:operation_value]};#{Time.now}\n"
    end

    {
        :account => args[:account].to_s,
        :initial_balance => args[:operation_value].to_f.round(2)
    }
end

def operation_d(args)
    all = File.open(args[:auth_file], "r").read
    found_account = false
    all.split("\n").each do |entry|
        values = entry.split(";")
        if values[0] == args[:account]
            found_account = true
        end
    end

    unless found_account
        return { :error => "Account not found"}
    end

    File.open(args[:auth_file], "a") do |f|
        f << "#{args[:account]};d;#{args[:operation_value]};#{Time.now}\n"
    end

    {
        :account => args[:account].to_s,
        :deposit => args[:operation_value].to_f.round(2)
    }
end

def operation_w(args)
    all = File.open(args[:auth_file], "r").read
    balance = 0.0
    found_account = false
    all.split("\n").each do |entry|
        values = entry.split(";")
        if values[0] == args[:account]
            found_account = true

            if values[1] == "d"
                balance += values[2].to_f
            end

            if values[1] == "w"
                balance -= values[2].to_f
            end
        end
    end

    unless found_account
        return { :error => "Account not found"}
    end

    if balance - args[:operation_value].to_f < 0
        return { :error => "Invalid amount"}
    end

    File.open(args[:auth_file], "a") do |f|
        f << "#{args[:account]};w;#{args[:operation_value]};#{Time.now}\n"
    end

    {
        :account  => args[:account].to_s,
        :withdraw => args[:operation_value].to_f.round(2)
    }
end

def operation_g(args)
    all = File.open(args[:auth_file], "r").read
    balance = 0.0
    found_account = false
    all.split("\n").each do |entry|
        values = entry.split(";")
        if values[0] == args[:account]
            found_account = true
            if values[1] == "d"
                balance += values[2].to_f
            end

            if values[1] == "w"
                balance -= values[2].to_f
            end
        end
    end

    unless found_account
        return { :error => "Account not found"}
    end

    File.open(args[:auth_file], "a") do |f|
        f << "#{args[:account]};g;#{args[:operation_value]};#{Time.now}\n"
    end

    {
        :account => args[:account].to_s,
        :balance => (balance.to_f)
    }
end

# bank is a server than simulates a bank, whose job is to keep track
# of the balance of its customers. It will receive communications
# from atm clients on the specified TCP port. Example interactions
# with bank and the atm are given at the bottom of the main page.

options = {}

OptionParser.new do |opts|  
  opts.banner = "Usage: bank [-p <port>] [-s <auth-file>]"
  opts.separator  ""
  opts.separator  "Options"

  text = "The port that bank should listen on. The default is 3000."
  opts.on("-p <port>","",text) do |input|
    exit(EXIT_CODE) unless is_valid_port?(input)
    options[:port] = input
  end

  text = "The name of the auth file. If not supplied, defaults to \"bank.auth\""
  opts.on("-s <auth-file>","",text) do |input|
    exit(EXIT_CODE) unless is_valid_auth_file?(input)
    options[:auth_file] = input
  end
end.parse!

# Debug: print received options
debug options.inspect

# Default Parameters Values
port      = (options[:port]      || "3000").to_i
auth_file = options[:auth_file]  || "bank.auth"

# ...  if the specified file already exists,
# bank should exit with return code 255.
if File.exist?(auth_file)
  debug "File already exists: #{auth_file}"
  exit(EXIT_CODE)
end

# Once the auth file is written completely, 
# bank prints "created" (followed by a newline)
# to stdout. bank will not change the auth file
# once "created" has been printed.
begin
  f = File.new(auth_file,  "w")
  f.close
  puts "created"
  STDOUT.flush
rescue Errno::EACCES
  debug "No permission to write file: #{auth_file}"
  exit(EXIT_CODE)
end

#
## Bank TCP Server
#
# If an error is detected in the protocol's communication,
# atm should exit with return code 63, while bank should
# print "protocol_error" to stdout (followed by a newline)
# and roll back (i.e., undo any changes made by) the current
# transaction.
server = TCPServer.new("127.0.0.1", port)
begin
  loop do
    client = server.accept    # Wait for a client to connect

    # A timeout occurs if the other program does not respond
    # within 10 seconds. If the atm observes the timeout, it
    # should exit with return code 63, while if the bank observes it,
    # it should print "protocol_error" to stdout (followed by a newline)
    # and rollback the current transaction. The non-observing party
    # need not do anything in particular.
#    timeout(100) do
#      debug "timeout"
#      client.puts "protocol_error"
#    end

    client_input = client.gets
    debug "received #{client_input}"

    begin
       client_input = JSON.parse(client_input)
    rescue JSON::ParserError
      debug "failed to parse json"
      client.puts "protocol_error"
    end

    # Verify Input
    if !client_input["input"] || !client_input["input"].is_a?(Array)
        debug "invalid input"
        client.puts "protocol_error"
        client.close
    end

    # Extract arguments from client input
    args = {}
    client_input["input"].each_with_index do |v, index|
      key = nil

      case v
        when "-a"
          key = "account"
        when "-c"
          key = "card_file"
        when "-s"
          key = "auth_file"
        when "-n", "-d", "-w", "-g"
          args[:operation] = v
          key = "operation_value" unless v=="-g"  # -g doesn't have a value
      end

      # Index check -- just to make sure that there is
      # a next value followed by the key. E.g.,
      # When the key is "-n" we supposed that there is
      # the next value, which will be amount for instance.
      # So we check if the index exists (index+1) as some
      # keys doesn't need indexes, such as "-g".
      if key && (index + 1 <= client_input["input"].count)
        args[:"#{key}"] = client_input["input"][index + 1]
      end
    end

    # Verify Input
    if !are_valid_args?(args)
      debug "invalid args"
      client.puts "protocol_error"
      client.close
      next
    end

    # Execute Operations
    output = case args[:operation]
      when "-n"
        operation_n(args)
      when "-d"
        operation_d(args)
      when "-w"
        operation_w(args)
      when "-g"
        operation_g(args)
      else
        debug "invalid operation"
        debug "args: #{args}"
        exit(EXIT_CODE)
    end

    unless output
      debug "invalid output"
      exit(EXIT_CODE)
    end

    puts output.to_json         # prints on console
    STDOUT.flush
    client.puts output.to_json  # prints on socket
    client.close
  end
rescue => e
  debug "generic error #{e.class}: #{e.message} \nBacktrace #{e.backtrace}"
  exit(EXIT_CODE)
end