#!/usr/bin/env ruby
require 'optparse'
require 'socket'
require 'timeout'
require 'json'
require_relative 'validations.rb'
require_relative 'common.rb'

options = {}

OptionParser.new do |opts|  
  opts.banner = "Usage: bank [-p <port>] [-s <auth-file>]"
  opts.separator  ""
  opts.separator  "Options"

  text = "The port that bank should listen on. The default is 3000."
  opts.on("-p <port>","",text) do |input|
    exit(EXIT_CODE) unless is_valid_port?(input)
    options[:port] = input
  end

  text = "The name of the auth file. If not supplied, defaults to \"bank.auth\""
  opts.on("-s <auth-file>","",text) do |input|
    exit(EXIT_CODE) unless is_valid_auth_file?(input)
    options[:auth_file] = input
  end
end.parse!

# Debug: print received options
debug options.inspect

# Default Parameters Values
port      = (options[:port]      || "3000").to_i
auth_file = options[:auth_file]  || "bank.auth"

# ...  if the specified file already exists,
# bank should exit with return code 255.
if File.exist?(auth_file)
  debug "File already exists: #{auth_file}"
  exit(EXIT_CODE)
end

# Once the auth file is written completely, 
# bank prints "created" (followed by a newline)
# to stdout. bank will not change the auth file
# once "created" has been printed.
begin
  f = File.new(auth_file,  "w")
  f.close
  puts "created"
rescue Errno::EACCES
  debug "No permission to write file: #{auth_file}"
  exit(EXIT_CODE)
end

#
## Bank TCP Server
#
# If an error is detected in the protocol's communication,
# atm should exit with return code 63, while bank should
# print "protocol_error" to stdout (followed by a newline)
# and roll back (i.e., undo any changes made by) the current
# transaction.
server = TCPServer.new("127.0.0.1", port)
loop do
  client = server.accept    # Wait for a client to connect

  # A timeout occurs if the other program does not respond
  # within 10 seconds. If the atm observes the timeout, it
  # should exit with return code 63, while if the bank observes it,
  # it should print "protocol_error" to stdout (followed by a newline)
  # and rollback the current transaction. The non-observing party
  # need not do anything in particular.
  timeout(10) do
    debug "timeout"
    client.puts "protocol_error"
  end

  client_input = client.gets
  begin
     client_input = JSON.parse(client_input)
  rescue JSON::ParserError
    debug "failed to parse json"
    client.puts "protocol_error"
  end

  # Verify Input
  if !client_input["input"] || !client_input["input"].is_a?(Array)
      debug "invalid input"
      client.puts "protocol_error"
      client.close
  end

  # Extract arguments from client input
  args = {}
  client_input["input"].each_with_index do |v ,index|
    key = nil

    case v
      when "-a"
        key = "account"
      when "-c"
        key = "card_file"
      when ["-n", "-d", "-w", "-g"].include?(v)
        args[:operation] == v
        key = "operation_value" unless v=="-g"  # -g doesn't have a value
    end

    # Index check
    if key && (index + 1 <= client_input["index"].count)
      args[:"#{key}"] = client_input["input"][index + 1]
    end
  end

  # Verify Input
  if !are_valid_args?(args)
    client.puts "protocol_error"
    client.close
  end

  # Execute Operations
  output = case args[:operation]
    when "-n"
      # ... code to store money
      {
        :account => args[:account].to_s,
        :initial_balance => ('%.2f' % args[:operation_value].to_f)
      }

    when "-d"
      # ... code to deposit money

      {
        :account => args[:account].to_s,
        :deposit => ('%.2f' % args[:operation_value].to_f)
      }

    when "-w"
      # ... code to withdraw money
      {
        :account  => args[:account].to_s,
        :withdraw => ('%.2f' % args[:operation_value].to_f)
      }.to_json

    when "-g"
      # ... code to get balance
      balance = 1.00 # dummy value!!

      {
        :account => args[:account].to_s,
        :balance => ('%.2f' % balance.to_f)
      }
  end

  client.puts output.json
  client.close
end

=begin
  
- Missing code to execute operations (above)
- Missing proper validation for operation (are_valid_args?)
  Checks must be the same as listed on the atm missing things
  In the end of the file
  
=end